{"name":"Flexiblecallback","tagline":"FlexibleCallback allows for more flexibility in callback functions.","body":"FlexibleCallback\r\n================\r\n\r\n[![Build Status](https://img.shields.io/travis/schlaus/FlexibleCallback.svg?style=flat-square)](https://travis-ci.org/schlaus/FlexibleCallback)\r\n[![Coverage Status](https://img.shields.io/coveralls/schlaus/FlexibleCallback/master.svg?style=flat-square)](https://coveralls.io/r/schlaus/FlexibleCallback?branch=master)\r\n[![Latest Version](https://img.shields.io/github/release/schlaus/FlexibleCallback.svg?style=flat-square)](https://packagist.org/packages/schlaus/flexiblecallback)\r\n[![Total Downloads](https://img.shields.io/packagist/dt/schlaus/FlexibleCallback.svg?style=flat-square)](https://packagist.org/packages/schlaus/flexiblecallback)\r\n[![Issues open](https://img.shields.io/github/issues/schlaus/FlexibleCallback.svg?style=flat-square)](https://github.com/schlaus/FlexibleCallback/issues)\r\n[![MIT license](https://img.shields.io/badge/license-MIT-blue.svg?style=flat-square)](http://schlaus.mit-license.org)\r\n\r\nFlexibleCallback allows for more flexibility in callback functions.\r\n\r\nSpecifically, it allows you to:\r\n* Unregister callbacks even if it's not otherwise possible\r\n* Change an already registered callback\r\n* Create callback queues\r\n* Simply return values instead of running a function\r\n\r\n#### So where would I need something like that?\r\n\r\nWell, for example `register_shutdown_function()` won't allow you to unregister or change a callback once it's been registered. FlexibleCallback allows you to circumvent that limitation.\r\n\r\nInstallation\r\n------------\r\n```\r\ncomposer require schlaus/flexiblecallback\r\n```\r\n\r\n...or just download and include `FlexibleCallback.php`. There are no dependencies, so you're good to go.\r\n\r\nUsage\r\n-----\r\n#### The basics\r\n```\r\nuse Schlaus\\FlexibleCallback\\FlexibleCallback;\r\n\r\n$closure = new FlexibleCallback(function() {\r\n    return \"Hello, world!\";\r\n});\r\n\r\n$closure();     // \"Hello, world!\"\r\n\r\n// register_shutdown_function($closure);\r\n\r\n$plainValue = new FlexibleCallback(\"I'm a return value\");\r\n\r\n$plainValue();  // \"I'm a return value\"\r\n\r\n$queue = new FlexibleCallback(\r\n    array(\r\n        function() {\r\n            return \"Callback 1\";\r\n        },\r\n        function() {\r\n            return \"Callback 2\";\r\n        }\r\n    )\r\n);\r\n\r\n$queue();       // \"Callback 2\"\r\n\r\n$queue->unregister();\r\n\r\n$queue();       // null\r\n```\r\n\r\n#### Change a callback afterwards\r\n```\r\n$callback = new FlexibleCallback(\"I don't do anything\");\r\n\r\n$callback->setCallback(\"I'm much more useful\");\r\n\r\n$callback();    // \"I'm much more useful\"\r\n\r\n$callback->setCallback(function() {\r\n    return \"But I'm the best\";\r\n});\r\n\r\n$callback();    // \"But I'm the best\"\r\n\r\n// To enforce a callback type there are two handy methods\r\n\r\n$callback = new FlexibleCallback;\r\n\r\n$callback->setReturnValue(\"I'm a string\")   // Only allows non-callables\r\n\r\n$callback->setCallbackFunction(function() { // Only allows callables\r\n    // Awesome things\r\n});\r\n\r\n$callback->setCallbackFunction(\"But I'm not a function!\") // InvalidArgumentException\r\n```\r\n\r\n#### Callback queues\r\n```\r\n// Create a queue while you're instancing the class...\r\n$queue = new FlexibleCallback(array(\r\n    function() {},\r\n    function() {},\r\n    //...\r\n));\r\n// NOTE: This is a queue, not a stack. First in is first out.\r\n\r\n// ... or change an already existing object into a queue\r\n$queue = new FlexibleCallback;\r\n$queue->pushCallbackFunction(function(){});\r\n$queue->pushCallbackFunction(function(){});\r\n\r\n// A queue can only contain callables, not values\r\n$queue = new FlexibleCallback(\"string\");\r\n$queue->pushCallbackFunction(function() {\r\n    return \"I'm a function\";\r\n});\r\n\r\n$queue();       // \"I'm a function\"\r\n```\r\n\r\n#### Callback arguments in queues\r\n```\r\n// By default, the same arguments are passed to each callback.\r\n// If a callback in queue returns false, queue execution stops.\r\n// It's possible to change this behaviour so, that instead\r\n// return values are given as the first argument to subsequent\r\n// callbacks.\r\n\r\n$queue = new FlexibleCallback;\r\n$queue->includePreviousReturnValue();\r\n\r\n$queue = setCallbackFunction(array(\r\n    function($arg1, $arg2) {\r\n        // Since this is the first callback, $arg1 is always null\r\n        // and $arg2 is the first argument passed by the caller\r\n        return false;\r\n    },\r\n    function($arg1, $arg2) {\r\n        // $arg1 is now false, and $arg2 is the same as it was\r\n        // in the previous callback.\r\n    }\r\n));\r\n\r\n\r\n$queue->excludePreviousReturnValue(); // back to default\r\n```\r\n\r\n#### Checking what's been loaded\r\n```\r\n$callback = new FlexibleCallback(\"Testing!\");\r\n\r\n$callback->getCallback();   // \"Testing!\"\r\n\r\n$callback->getType();       // \"value\"\r\n\r\n$callback->pushCallbackFunction(function() {\r\n    return \"Hello!\";\r\n});\r\n\r\n$callback->getType();       // \"callable\"\r\n\r\n$function = $callback->getCallback();\r\n\r\n$function();                // \"Hello!\"\r\n\r\n$callback->pushCallbackFunction(/*...*/);\r\n\r\n$callback->getType();       // \"queue\"\r\n\r\n// $queue will contain all callbacks in queue\r\n$queue = $callback->getCallback();\r\n\r\n$callback->setReturnValue(null);\r\n\r\n$callback->getType();       // null\r\n\r\n$callback->unregister();\r\n\r\n$callback->getType();       // null\r\n```\r\n\r\n#### Converting the queue to a stack (sort of)\r\n```\r\n$callback->setCallbackFunction(\r\n    array_reverse($callback->getCallback())\r\n);\r\n```\r\n\r\nLicense\r\n-------\r\n[MIT](http://schlaus.mit-license.org)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}